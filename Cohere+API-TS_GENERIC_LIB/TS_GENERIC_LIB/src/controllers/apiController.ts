/**
 * Cohere APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiError } from '@apimatic/core';
import { ApiResponse, RequestOptions } from '../core';
import {
  ClassifyRequest,
  classifyRequestSchema,
} from '../models/classifyRequest';
import {
  ClassifyResponse,
  classifyResponseSchema,
} from '../models/classifyResponse';
import {
  DetectLanguageRequest,
  detectLanguageRequestSchema,
} from '../models/detectLanguageRequest';
import {
  DetectLanguageResponse,
  detectLanguageResponseSchema,
} from '../models/detectLanguageResponse';
import {
  DetokenizeRequest,
  detokenizeRequestSchema,
} from '../models/detokenizeRequest';
import {
  DetokenizeResponse,
  detokenizeResponseSchema,
} from '../models/detokenizeResponse';
import {
  GenerateRequest,
  generateRequestSchema,
} from '../models/generateRequest';
import { Generation, generationSchema } from '../models/generation';
import { RerankRequest, rerankRequestSchema } from '../models/rerankRequest';
import { RerankResponse, rerankResponseSchema } from '../models/rerankResponse';
import {
  SummarizeRequest,
  summarizeRequestSchema,
} from '../models/summarizeRequest';
import {
  SummarizeResponse,
  summarizeResponseSchema,
} from '../models/summarizeResponse';
import {
  TokenizeRequest,
  tokenizeRequestSchema,
} from '../models/tokenizeRequest';
import {
  TokenizeResponse,
  tokenizeResponseSchema,
} from '../models/tokenizeResponse';
import { optional } from '../schema';
import { BaseController } from './baseController';

export class ApiController extends BaseController {
  /**
   * This endpoint takes tokens using byte-pair encoding and returns their text representation. To learn
   * more about tokenization and byte pair encoding, see the tokens page.
   *
   * @param body
   * @return Response from the API call
   */
  async detokenize(
    body?: DetokenizeRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<DetokenizeResponse>> {
    const req = this.createRequest('POST', '/detokenize');
    const mapped = req.prepareArgs({
      body: [body, optional(detokenizeRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.callAsJson(detokenizeResponseSchema, requestOptions);
  }

  /**
   * This endpoint generates realistic text conditioned on a given input.
   *
   * @param body
   * @return Response from the API call
   */
  async generate(
    body?: GenerateRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Generation>> {
    const req = this.createRequest('POST', '/generate');
    const mapped = req.prepareArgs({
      body: [body, optional(generateRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.throwOn(400, ApiError, 'Bad Request');
    req.throwOn(498, ApiError, 'Blocked Input or Output');
    req.throwOn(500, ApiError, 'Internal Server Error');
    return req.callAsJson(generationSchema, requestOptions);
  }

  /**
   * This endpoint identifies which language each of the provided texts is written in.
   *
   * @param body
   * @return Response from the API call
   */
  async detectLanguage(
    body?: DetectLanguageRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<DetectLanguageResponse>> {
    const req = this.createRequest('POST', '/detect-language');
    const mapped = req.prepareArgs({
      body: [body, optional(detectLanguageRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.callAsJson(detectLanguageResponseSchema, requestOptions);
  }

  /**
   * This endpoint splits input text into smaller units called tokens using byte-pair encoding (BPE). To
   * learn more about tokenization and byte pair encoding, see the tokens page.
   *
   * @param body
   * @return Response from the API call
   */
  async tokenize(
    body?: TokenizeRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TokenizeResponse>> {
    const req = this.createRequest('POST', '/tokenize');
    const mapped = req.prepareArgs({
      body: [body, optional(tokenizeRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.throwOn(400, ApiError, 'Bad Request');
    req.throwOn(500, ApiError, 'Internal Server Error');
    return req.callAsJson(tokenizeResponseSchema, requestOptions);
  }

  /**
   * This endpoint makes a prediction about which label fits the specified text inputs best. To make a
   * prediction, Classify uses the provided `examples` of text + label pairs as a reference.
   *
   * Note: [Custom Models](/training-representation-models) trained on classification examples don't
   * require the `examples` parameter to be passed in explicitly.
   *
   * @param body
   * @return Response from the API call
   */
  async classify(
    body?: ClassifyRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ClassifyResponse>> {
    const req = this.createRequest('POST', '/classify');
    const mapped = req.prepareArgs({
      body: [body, optional(classifyRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.throwOn(400, ApiError, 'Bad Request');
    req.throwOn(500, ApiError, 'Internal Server Error');
    return req.callAsJson(classifyResponseSchema, requestOptions);
  }

  /**
   * This endpoint generates a summary in English for a given text.
   *
   * @param body
   * @return Response from the API call
   */
  async summarize(
    body?: SummarizeRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SummarizeResponse>> {
    const req = this.createRequest('POST', '/summarize');
    const mapped = req.prepareArgs({
      body: [body, optional(summarizeRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.callAsJson(summarizeResponseSchema, requestOptions);
  }

  /**
   * This endpoint takes in a query and a list of texts and produces an ordered array with each text
   * assigned a relevance score.
   *
   * @param body
   * @return Response from the API call
   */
  async rerank(
    body?: RerankRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<RerankResponse>> {
    const req = this.createRequest('POST', '/rerank');
    const mapped = req.prepareArgs({
      body: [body, optional(rerankRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.callAsJson(rerankResponseSchema, requestOptions);
  }
}
